{"task_id": "Rust/0", "prompt": "/// The function takes in `a` and `b` which are `u32` and returns `a - b` as `u32`. An underflow\n/// should result in 0.\nfn subtract_without_underflow(a: u32, b: u32) -> u32 {", "instruction": "Write an idiomatic Rust function `subtract_without_underflow(a: u32, b: u32) -> u32` to solve the following problem:\nThe function takes in `a` and `b` which are `u32` and returns `a - b` as `u32`. An underflow should result in 0.", "test": "#[cfg(test)]\nmod test {\n    use super::*;\n\n    #[test]\n    fn test_subtract_without_underflow() {\n        assert_eq!(subtract_without_underflow(0, 0), 0);\n        assert_eq!(subtract_without_underflow(3, 10), 0);\n        assert_eq!(subtract_without_underflow(10, 3), 7);\n    }\n}", "entry_point": "subtract_without_underflow", "canonical_solution": "fn subtract_without_underflow(a: u32, b: u32) -> u32 {\n    a.saturating_sub(b)\n}", "contained": {"functions": ["saturating_sub", "", ""], "operators": ["", "", ""]}}
{"task_id": "Rust/1", "prompt": "/// The function takes in `a` and `b` which are `u32` and returns `a - b` as `u32`. It should return\n/// if the operation underflows.\nfn check_if_underflow(a: u32, b: u32) -> bool {", "instruction": "Write an idiomatic Rust function `check_if_underflow(a: u32, b: u32) -> bool` to solve the following problem:\nThe function takes in `a` and `b` which are `u32` and returns `a - b` as `u32`. It should return if the operation underflows.", "test": "#[cfg(test)]\nmod test {\n    use super::*;\n\n    #[test]\n    fn test_check_if_underflow() {\n        assert_eq!(check_if_underflow(0, 0), false);\n        assert_eq!(check_if_underflow(3, 10), true);\n        assert_eq!(check_if_underflow(10, 3), false);\n    }\n}", "entry_point": "check_if_underflow", "canonical_solution": "fn check_if_underflow(a: u32, b: u32) -> bool {\n    a.checked_sub(b).is_none()\n}", "contained": {"functions": ["checked_sub", "is_none", ""], "operators": ["", "", ""]}}
{"task_id": "Rust/2", "prompt": "/// The function takes in `a` and `b` which are `u32` and returns `a + b` as `u32`. It should return\n/// if the operation overflows.\nfn check_if_overflow(a: u32, b: u32) -> bool {", "instruction": "Write an idiomatic Rust function `check_if_overflow(a: u32, b: u32) -> bool` to solve the following problem:\nThe function takes in `a` and `b` which are `u32` and returns `a + b` as `u32`. It should return if the operation overflows.", "test": "#[cfg(test)]\nmod test {\n    use super::*;\n\n    #[test]\n    fn test_check_if_overflow() {\n        assert_eq!(check_if_overflow(0, 0), false);\n        assert_eq!(check_if_overflow(u32::MAX, 1), true);\n    }\n}", "entry_point": "check_if_overflow", "canonical_solution": "fn check_if_overflow(a: u32, b: u32) -> bool {\n    a.checked_add(b).is_none()\n}", "contained": {"functions": ["checked_add", "is_none", ""], "operators": ["", "", ""]}}
{"task_id": "Rust/3", "prompt": "/// The function takes in `a` and `b` which are `u32` and computes `a + b` in the precision of `u32`.\n/// If the operation overflows, it should return the maximum number else the result.\nfn add_without_overflow(a: u32, b: u32) -> u32 {", "instruction": "Write an idiomatic Rust function `add_without_overflow(a: u32, b: u32) -> u32` to solve the following problem:\nThe function takes in `a` and `b` which are `u32` and computes `a + b` in the precision of `u32`. If the operation overflows, it should return the maximum number else the result.", "test": "#[cfg(test)]\nmod test {\n    use super::*;\n\n    #[test]\n    fn test_add_without_overflow() {\n        assert_eq!(add_without_overflow(0, 0), 0);\n        assert_eq!(add_without_overflow(4, 10), 14);\n        assert_eq!(add_without_overflow(10, 4), 14);\n        assert_eq!(add_without_overflow(u32::MAX, 1), u32::MAX);\n        assert_eq!(add_without_overflow(1, u32::MAX), u32::MAX);\n    }\n}", "entry_point": "add_without_overflow", "canonical_solution": "fn add_without_overflow(a: u32, b: u32) -> u32 {\n    a.saturating_add(b)\n}", "contained": {"functions": ["saturating_add", "", ""], "operators": ["", "", ""]}}
{"task_id": "Rust/4", "prompt": "/// The function takes in `a` and `b` which are `u32` and computes `a * b` in the precision of `u32`.\n/// If an overflow occurs, the maximum number should be returned.\nfn multi_without_overflow(a: u32, b: u32) -> u32 {", "instruction": "Write an idiomatic Rust function `multi_without_overflow(a: u32, b: u32) -> u32` to solve the following problem:\nThe function takes in `a` and `b` which are `u32` and computes `a * b` in the precision of `u32`. If an overflow occurs, the maximum number should be returned.", "test": "#[cfg(test)]\nmod test {\n    use super::*;\n\n    #[test]\n    fn test_multi_without_overflow() {\n        assert_eq!(multi_without_overflow(0, 0), 0);\n        assert_eq!(multi_without_overflow(10, 2), 20);\n        assert_eq!(multi_without_overflow(u32::MAX / 2, 3), u32::MAX);\n    }\n}", "entry_point": "multi_without_overflow", "canonical_solution": "fn multi_without_overflow(a: u32, b: u32) -> u32 {\n    a.saturating_mul(b)\n}", "contained": {"functions": ["saturating_mul", "", ""], "operators": ["", "", ""]}}
{"task_id": "Rust/5", "prompt": "/// The function takes in `a` and `b` which are `u64` and computes `a * b` in the precision of `u64`.\n/// If the operation overflows, it should return the maximum number else the result.\nfn multi_without_overflow(a: u64, b: u64) -> u64 {", "instruction": "Write an idiomatic Rust function `multi_without_overflow(a: u64, b: u64) -> u64` to solve the following problem:\nThe function takes in `a` and `b` which are `u64` and computes `a * b` in the precision of `u64`. If the operation overflows, it should return the maximum number else the result.", "test": "#[cfg(test)]\nmod test {\n    use super::*;\n\n    #[test]\n    fn test_multi_without_overflow() {\n        assert_eq!(multi_without_overflow(0, 0), 0);\n        assert_eq!(multi_without_overflow(3, 10), 30);\n        assert_eq!(multi_without_overflow(10, 3), 30);\n        assert_eq!(multi_without_overflow(u64::MAX / 2, 3), u64::MAX);\n    }\n}", "entry_point": "multi_without_overflow", "canonical_solution": "fn multi_without_overflow(a: u64, b: u64) -> u64 {\n    a.saturating_mul(b)\n}", "contained": {"functions": ["saturating_mul", "", ""], "operators": ["", "", ""]}}
{"task_id": "Rust/6", "prompt": "/// The function takes in `a` as `u32` and `b` as `u64` and computes `a + b` in the precision of\n/// `u128`.\nfn add_with_diff_types(a: u32, b: u64) -> u128 {", "instruction": "Write an idiomatic Rust function `add_with_diff_types(a: u32, b: u64) -> u128` to solve the following problem:\nThe function takes in `a` as `u32` and `b` as `u64` and computes `a + b` in the precision of `u128`.", "test": "#[cfg(test)]\nmod test {\n    use super::*;\n\n    #[test]\n    fn test_add_with_diff_types() {\n        assert_eq!(add_with_diff_types(0, 0), 0);\n        assert_eq!(add_with_diff_types(3, 20), 23);\n        assert_eq!(add_with_diff_types(20, 3), 23);\n        assert_eq!(\n            add_with_diff_types(u32::MAX, u64::MAX),\n            (u32::MAX as u128) + (u64::MAX as u128)\n        );\n    }\n}", "entry_point": "add_with_diff_types", "canonical_solution": "fn add_with_diff_types(a: u32, b: u64) -> u128 {\n    u128::from(a) + u128::from(b)\n}", "contained": {"functions": ["u128::from", "", ""], "operators": ["", "", ""]}}
{"task_id": "Rust/7", "prompt": "/// The function takes in `a` which is `u32` and should convert it to the next smaller type safely.\nfn convert_to_smaller_type(a: u32) -> Option<u16> {", "instruction": "Write an idiomatic Rust function `convert_to_smaller_type(a: u32) -> Option<u16>` to solve the following problem:\nThe function takes in `a` which is `u32` and should convert it to the next smaller type safely.", "test": "#[cfg(test)]\nmod test {\n    use super::*;\n\n    #[test]\n    fn test_convert_to_smaller_type() {\n        assert_eq!(convert_to_smaller_type(0), Some(0));\n        assert_eq!(convert_to_smaller_type(234), Some(234));\n        assert_eq!(convert_to_smaller_type(u16::MAX as u32), Some(u16::MAX));\n        assert_eq!(convert_to_smaller_type(u32::MAX), None);\n    }\n}", "entry_point": "convert_to_smaller_type", "canonical_solution": "fn convert_to_smaller_type(a: u32) -> Option<u16> {\n    a.try_into().ok()\n}", "contained": {"functions": ["try_into", "ok", ""], "operators": ["", "", ""]}}
{"task_id": "Rust/8", "prompt": "/// The function takes in `a` which is `u32` which is in little endian and should convert it to the\n/// endian of the operating system.\nfn from_little_endian_to_current_endian(a: u32) -> u32 {", "instruction": "Write an idiomatic Rust function `from_little_endian_to_current_endian(a: u32) -> u32` to solve the following problem:\nThe function takes in `a` which is `u32` which is in little endian and should convert it to the endian of the operating system.", "test": "#[cfg(test)]\nmod test {\n    use super::*;\n\n    #[test]\n    fn test_from_little_endian_to_current_endian() {\n        assert_eq!(\n            from_little_endian_to_current_endian(0x12345678),\n            if cfg!(target_endian = \"big\") {\n                0x78563412\n            } else {\n                0x12345678\n            }\n        );\n    }\n}", "entry_point": "from_little_endian_to_current_endian", "canonical_solution": "fn from_little_endian_to_current_endian(a: u32) -> u32 {\n    u32::from_le(a)\n}", "contained": {"functions": ["u32::from_le", "", ""], "operators": ["", "", ""]}}
{"task_id": "Rust/9", "prompt": "/// The function takes in `a` which is `u32` and should count the ones in it's binary representation.\nfn count_ones_in_binary(a: u32) -> u32 {", "instruction": "Write an idiomatic Rust function `count_ones_in_binary(a: u32) -> u32` to solve the following problem:\nThe function takes in `a` which is `u32` and should count the ones in it's binary representation.", "test": "#[cfg(test)]\nmod test {\n    use super::*;\n\n    #[test]\n    fn test_count_ones_in_binary() {\n        assert_eq!(count_ones_in_binary(0b010110), 3);\n        assert_eq!(count_ones_in_binary(0b010111), 4);\n        assert_eq!(count_ones_in_binary(0b000000000), 0);\n        assert_eq!(count_ones_in_binary(0b111111111), 9);\n    }\n}", "entry_point": "count_ones_in_binary", "canonical_solution": "fn count_ones_in_binary(a: u32) -> u32 {\n    a.count_ones()\n}", "contained": {"functions": ["count_ones", "", ""], "operators": ["", "", ""]}}
{"task_id": "Rust/10", "prompt": "use std::path::{Path, PathBuf};\n\n/// The function should take in an os path and a file name string slice and should combine them to a\n/// path.\nfn combine_to_path(path: &Path, file_name: &str) -> PathBuf {", "instruction": "Write an idiomatic Rust function `combine_to_path(path: &Path, file_name: &str) -> PathBuf` to solve the following problem:\nThe function should take in an os path and a file name string slice and should combine them to a path.\nUse the following context:\n```rust\nuse std::path::{Path, PathBuf};\n\n```", "test": "#[cfg(test)]\nmod test {\n    use super::*;\n\n    #[test]\n    fn test_combine_to_path() {\n        assert_eq!(\n            combine_to_path(Path::new(\"/tmp\"), \"file.txt\"),\n            PathBuf::from(\"/tmp/file.txt\")\n        );\n        assert_eq!(\n            combine_to_path(Path::new(\"/tmp/\"), \"file.txt\"),\n            PathBuf::from(\"/tmp/file.txt\")\n        );\n    }\n}", "entry_point": "combine_to_path", "canonical_solution": "use std::path::{Path, PathBuf};\n\nfn combine_to_path(path: &Path, file_name: &str) -> PathBuf {\n    path.join(file_name)\n}", "contained": {"functions": ["join", "", ""], "operators": ["", "", ""]}}
{"task_id": "Rust/11", "prompt": "use std::path::{Path, PathBuf};\n\n/// The function should take in an os path and divide it into the path and the filename. Example:\n/// \"/a/b/c.txt\" -> (\"/a/b\", \"c.txt\")\nfn divide_into_path_and_file(path: &Path) -> (Option<PathBuf>, String) {", "instruction": "Write an idiomatic Rust function `divide_into_path_and_file(path: &Path) -> (Option<PathBuf>, String)` to solve the following problem:\nThe function should take in an os path and divide it into the path and the filename. Example: \"/a/b/c.txt\" -> (\"/a/b\", \"c.txt\")\nUse the following context:\n```rust\nuse std::path::{Path, PathBuf};\n\n```", "test": "#[cfg(test)]\nmod test {\n    use super::*;\n\n    #[test]\n    fn test_divide_into_path_and_file() {\n        assert_eq!(divide_into_path_and_file(Path::new(\"\")), (None, \"\".to_string()));\n        assert_eq!(\n            divide_into_path_and_file(Path::new(\"tmp/src/main.rs\")),\n            (Some(PathBuf::from(\"tmp/src\")), \"main.rs\".to_string())\n        );\n        assert_eq!(\n            divide_into_path_and_file(Path::new(\"tmp/src\")),\n            (Some(PathBuf::from(\"tmp\")), \"src\".to_string())\n        );\n        assert_eq!(\n            divide_into_path_and_file(Path::new(\"tmp\")),\n            (Some(PathBuf::from(\"\")), \"tmp\".to_string())\n        );\n        assert_eq!(divide_into_path_and_file(Path::new(\"/\")), (None, \"\".to_string()));\n        assert_eq!(\n            divide_into_path_and_file(Path::new(\"/tmp/src/\")),\n            (Some(PathBuf::from(\"/tmp\")), \"src\".to_string())\n        );\n    }\n}", "entry_point": "divide_into_path_and_file", "canonical_solution": "use std::path::{Path, PathBuf};\n\nfn divide_into_path_and_file(path: &Path) -> (Option<PathBuf>, String) {\n    let parent_path = path.parent().map(|parent| parent.to_path_buf());\n    let file_name = path\n        .file_name()\n        .map(|name| name.to_string_lossy().into_owned())\n        .unwrap_or_default();\n\n    (parent_path, file_name)\n}", "contained": {"functions": ["parent", "file_name", "to_path_buf"], "operators": ["", "", ""]}}
{"task_id": "Rust/12", "prompt": "use std::path::Path;\n\n/// The function should take in an os path and should check weather it exists or not.\nfn check_if_path_exists(path: &Path) -> bool {", "instruction": "Write an idiomatic Rust function `check_if_path_exists(path: &Path) -> bool` to solve the following problem:\nThe function should take in an os path and should check weather it exists or not.\nUse the following context:\n```rust\nuse std::path::Path;\n\n```", "test": "#[cfg(test)]\nmod test {\n    use super::*;\n\n    #[test]\n    fn test_check_if_path_exists() {\n        // cannot assert functionality, only check if compiles\n    }\n}", "entry_point": "check_if_path_exists", "canonical_solution": "use std::path::Path;\n\nfn check_if_path_exists(path: &Path) -> bool {\n    path.exists()\n}", "contained": {"functions": ["exists", "", ""], "operators": ["", "", ""]}}
{"task_id": "Rust/13", "prompt": "use std::path::Path;\n\n/// The function should take in an os path and should count the parent directories. Example: \"/a/b/c\"\n/// -> 3\nfn count_parent_dirs(path: &Path) -> usize {", "instruction": "Write an idiomatic Rust function `count_parent_dirs(path: &Path) -> usize` to solve the following problem:\nThe function should take in an os path and should count the parent directories. Example: \"/a/b/c\" -> 3\nUse the following context:\n```rust\nuse std::path::Path;\n\n```", "test": "#[cfg(test)]\nmod test {\n    use super::*;\n\n    #[test]\n    fn test_count_parent_dirs() {\n        assert_eq!(count_parent_dirs(Path::new(\"/tmp\")), 1);\n        assert_eq!(count_parent_dirs(Path::new(\"/tmp/file.txt\")), 2);\n        assert_eq!(count_parent_dirs(Path::new(\"/tmp/foo/bar/baz\")), 4);\n        assert_eq!(count_parent_dirs(Path::new(\"/\")), 0);\n    }\n}", "entry_point": "count_parent_dirs", "canonical_solution": "use std::path::Path;\n\nfn count_parent_dirs(path: &Path) -> usize {\n    path.ancestors().count() - 1\n}", "contained": {"functions": ["ancestors", "count", ""], "operators": ["", "", ""]}}
{"task_id": "Rust/14", "prompt": "/// The function takes in a slice of `u32` and returns only the even numbers as a array of `u32`.\nfn filter_out_all_odd(numbers: &[u32]) -> Vec<u32> {", "instruction": "Write an idiomatic Rust function `filter_out_all_odd(numbers: &[u32]) -> Vec<u32>` to solve the following problem:\nThe function takes in a slice of `u32` and returns only the even numbers as a array of `u32`.", "test": "#[cfg(test)]\nmod test {\n    use super::*;\n\n    #[test]\n    fn test_filter_out_all_odd() {\n        assert_eq!(filter_out_all_odd(&[]), vec![]);\n        assert_eq!(filter_out_all_odd(&[1]), vec![]);\n        assert_eq!(filter_out_all_odd(&[1, 2, 5, 7, 8]), vec![2, 8]);\n    }\n}", "entry_point": "filter_out_all_odd", "canonical_solution": "fn filter_out_all_odd(numbers: &[u32]) -> Vec<u32> {\n    numbers.iter().filter(|x| *x % 2 == 0).copied().collect()\n}", "contained": {"functions": ["filter", "copied", ""], "operators": ["", "", ""]}}
{"task_id": "Rust/15", "prompt": "/// The function takes in a slice of `u32` and should return the sum of the numbers as `u32`.\nfn sum_up_numbers(numbers: &[u32]) -> u32 {", "instruction": "Write an idiomatic Rust function `sum_up_numbers(numbers: &[u32]) -> u32` to solve the following problem:\nThe function takes in a slice of `u32` and should return the sum of the numbers as `u32`.", "test": "#[cfg(test)]\nmod test {\n    use super::*;\n\n    #[test]\n    fn test_sum_up_numbers() {\n        assert_eq!(sum_up_numbers(&[]), 0);\n        assert_eq!(sum_up_numbers(&[1]), 1);\n        assert_eq!(sum_up_numbers(&[1, 2, 5, 10]), 18);\n    }\n}", "entry_point": "sum_up_numbers", "canonical_solution": "fn sum_up_numbers(numbers: &[u32]) -> u32 {\n    numbers.iter().sum()\n}", "contained": {"functions": ["sum", "", ""], "operators": ["", "", ""]}}
{"task_id": "Rust/16", "prompt": "/// The function takes in a slice of `u32` and should multiply all numbers to one result with\n/// precision of `u128`. Example: [2, 4, 6] -> 48\nfn mult_numbers(numbers: &[u32]) -> u128 {", "instruction": "Write an idiomatic Rust function `mult_numbers(numbers: &[u32]) -> u128` to solve the following problem:\nThe function takes in a slice of `u32` and should multiply all numbers to one result with precision of `u128`. Example: [2, 4, 6] -> 48", "test": "#[cfg(test)]\nmod test {\n    use super::*;\n\n    #[test]\n    fn test_mult_numbers() {\n        assert_eq!(mult_numbers(&[]), 1);\n        assert_eq!(mult_numbers(&[1]), 1);\n        assert_eq!(mult_numbers(&[2, 4, 6]), 48);\n        assert_eq!(mult_numbers(&[u32::MAX, 20]), u32::MAX as u128 * 20);\n    }\n}", "entry_point": "mult_numbers", "canonical_solution": "fn mult_numbers(numbers: &[u32]) -> u128 {\n    numbers.iter().cloned().map(u128::from).product()\n}", "contained": {"functions": ["product", "cloned", "u128::from"], "operators": ["", "", ""]}}
{"task_id": "Rust/17", "prompt": "/// The function takes in a slice of `u32` and a prefix. It should check if the first n numbers are\n/// the prefix.\nfn first_n_are_prefix(numbers: &[u32], prefix: &[u32]) -> bool {", "instruction": "Write an idiomatic Rust function `first_n_are_prefix(numbers: &[u32], prefix: &[u32]) -> bool` to solve the following problem:\nThe function takes in a slice of `u32` and a prefix. It should check if the first n numbers are the prefix.", "test": "#[cfg(test)]\nmod test {\n    use super::*;\n\n    #[test]\n    fn test_first_n_are_prefix() {\n        assert_eq!(first_n_are_prefix(&[], &[]), true);\n        assert_eq!(first_n_are_prefix(&[1], &[]), true);\n        assert_eq!(first_n_are_prefix(&[1, 2, 3, 4], &[1, 2, 3]), true);\n        assert_eq!(first_n_are_prefix(&[1, 2, 3, 4], &[1, 1]), false);\n    }\n}", "entry_point": "first_n_are_prefix", "canonical_solution": "fn first_n_are_prefix(numbers: &[u32], prefix: &[u32]) -> bool {\n    numbers.starts_with(prefix)\n}", "contained": {"functions": ["starts_with", "", ""], "operators": ["", "", ""]}}
{"task_id": "Rust/18", "prompt": "/// The function takes in two slices of `u32` and should append the second one to the first and\n/// return it as a array of `u32`.\nfn append_slice(a: &[u32], b: &[u32]) -> Vec<u32> {", "instruction": "Write an idiomatic Rust function `append_slice(a: &[u32], b: &[u32]) -> Vec<u32>` to solve the following problem:\nThe function takes in two slices of `u32` and should append the second one to the first and return it as a array of `u32`.", "test": "#[cfg(test)]\nmod test {\n    use super::*;\n\n    #[test]\n    fn test_append_slice() {\n        assert_eq!(append_slice(&[], &[]), vec![]);\n        assert_eq!(append_slice(&[1], &[]), vec![1]);\n        assert_eq!(append_slice(&[], &[1]), vec![1]);\n        assert_eq!(append_slice(&[1], &[2]), vec![1, 2]);\n        assert_eq!(append_slice(&[1, 2], &[3, 4, 5, 6]), vec![1, 2, 3, 4, 5, 6]);\n    }\n}", "entry_point": "append_slice", "canonical_solution": "fn append_slice(a: &[u32], b: &[u32]) -> Vec<u32> {\n    let mut combined = Vec::with_capacity(a.len() + b.len());\n    combined.extend_from_slice(a);\n    combined.extend_from_slice(b);\n    combined\n}", "contained": {"functions": ["with_capacity", "extend_from_slice", ""], "operators": ["", "", ""]}}
{"task_id": "Rust/19", "prompt": "/// The function takes in a slice of `u32` and should check if it is empty.\nfn check_if_is_empty(numbers: &[u32]) -> bool {", "instruction": "Write an idiomatic Rust function `check_if_is_empty(numbers: &[u32]) -> bool` to solve the following problem:\nThe function takes in a slice of `u32` and should check if it is empty.", "test": "#[cfg(test)]\nmod test {\n    use super::*;\n\n    #[test]\n    fn test_check_if_is_empty() {\n        assert_eq!(check_if_is_empty(&[]), true);\n        assert_eq!(check_if_is_empty(&[1]), false);\n    }\n}", "entry_point": "check_if_is_empty", "canonical_solution": "fn check_if_is_empty(numbers: &[u32]) -> bool {\n    numbers.is_empty()\n}", "contained": {"functions": ["is_empty", "", ""], "operators": ["", "", ""]}}
{"task_id": "Rust/20", "prompt": "use std::num::TryFromIntError;\n\n/// The function takes in an array of `u128`. It should try converting all of them to `u32` or return\n/// the first error.\nfn convert_or_error(numbers: &[u128]) -> Result<Vec<u32>, TryFromIntError> {", "instruction": "Write an idiomatic Rust function `convert_or_error(numbers: &[u128]) -> Result<Vec<u32>, TryFromIntError>` to solve the following problem:\nThe function takes in an array of `u128`. It should try converting all of them to `u32` or return the first error.\nUse the following context:\n```rust\nuse std::num::TryFromIntError;\n\n```", "test": "#[cfg(test)]\nmod test {\n    use super::*;\n\n    #[test]\n    fn test_convert_or_error() {\n        assert_eq!(convert_or_error(&[]), Ok(vec![]));\n        assert_eq!(convert_or_error(&[0]), Ok(vec![0]));\n        assert_eq!(convert_or_error(&[u32::MAX as u128]), Ok(vec![u32::MAX]));\n        assert!(convert_or_error(&[u32::MAX as u128 + 1]).is_err());\n    }\n}", "entry_point": "convert_or_error", "canonical_solution": "use std::num::TryFromIntError;\n\nfn convert_or_error(numbers: &[u128]) -> Result<Vec<u32>, TryFromIntError> {\n    numbers.iter().cloned().map(u32::try_from).collect()\n}", "contained": {"functions": ["map", "u32::try_from", "collect"], "operators": ["", "", ""]}}
{"task_id": "Rust/21", "prompt": "/// The function should take in a string slice and should count how many `a` are contained.\nfn count_a_in_str(string: &str) -> usize {", "instruction": "Write an idiomatic Rust function `count_a_in_str(string: &str) -> usize` to solve the following problem:\nThe function should take in a string slice and should count how many `a` are contained.", "test": "#[cfg(test)]\nmod test {\n    use super::*;\n\n    #[test]\n    fn test_count_a_in_str() {\n        assert_eq!(count_a_in_str(\"\"), 0);\n        assert_eq!(count_a_in_str(\"a\"), 1);\n        assert_eq!(count_a_in_str(\"aa\"), 2);\n        assert_eq!(count_a_in_str(\"abbbabba\"), 3);\n    }\n}", "entry_point": "count_a_in_str", "canonical_solution": "fn count_a_in_str(string: &str) -> usize {\n    string.matches('a').count()\n}", "contained": {"functions": ["matches", "count", ""], "operators": ["", "", ""]}}
{"task_id": "Rust/22", "prompt": "/// The function should take in a string slice and should check if it contains the pattern `ab`.\nfn str_contains_ab(string: &str) -> bool {", "instruction": "Write an idiomatic Rust function `str_contains_ab(string: &str) -> bool` to solve the following problem:\nThe function should take in a string slice and should check if it contains the pattern `ab`.", "test": "#[cfg(test)]\nmod test {\n    use super::*;\n\n    #[test]\n    fn test_str_contains_ab() {\n        assert_eq!(str_contains_ab(\"a\"), false);\n        assert_eq!(str_contains_ab(\"b\"), false);\n        assert_eq!(str_contains_ab(\"ab\"), true);\n        assert_eq!(str_contains_ab(\"ba\"), false);\n        assert_eq!(str_contains_ab(\"aabbbbaa\"), true);\n    }\n}", "entry_point": "str_contains_ab", "canonical_solution": "fn str_contains_ab(string: &str) -> bool {\n    string.contains(\"ab\")\n}", "contained": {"functions": ["contains", "", ""], "operators": ["", "", ""]}}
{"task_id": "Rust/23", "prompt": "/// The function should take in a string slice and should check if the string starts with `ab` and\n/// ends with `ba`.\nfn check_start_and_end_pat(string: &str) -> bool {", "instruction": "Write an idiomatic Rust function `check_start_and_end_pat(string: &str) -> bool` to solve the following problem:\nThe function should take in a string slice and should check if the string starts with `ab` and ends with `ba`.", "test": "#[cfg(test)]\nmod test {\n    use super::*;\n\n    #[test]\n    fn test_check_start_and_end_pat() {\n        assert_eq!(check_start_and_end_pat(\"abba\"), true);\n        assert_eq!(check_start_and_end_pat(\"ab\"), false);\n        assert_eq!(check_start_and_end_pat(\"ba\"), false);\n        assert_eq!(check_start_and_end_pat(\"abab\"), false);\n        assert_eq!(check_start_and_end_pat(\"ababbbbaba\"), true);\n    }\n}", "entry_point": "check_start_and_end_pat", "canonical_solution": "fn check_start_and_end_pat(string: &str) -> bool {\n    string.starts_with(\"ab\") && string.ends_with(\"ba\")\n}", "contained": {"functions": ["starts_with", "ends_with", ""], "operators": ["", "", ""]}}
{"task_id": "Rust/24", "prompt": "fn strip_newline(s: &mut String) {\n    if s.ends_with('\\n') {\n        s.pop();\n    }\n}\n\n/// The function takes in a mutable slice of strings. It should remove all new line character `\\n`\n/// from the end of each line by using the function `strip_newline`.\nfn strip_all_newlines(lines: &mut [String]) {", "instruction": "Write an idiomatic Rust function `strip_all_newlines(lines: &mut [String])` to solve the following problem:\nThe function takes in a mutable slice of strings. It should remove all new line character `\\n` from the end of each line by using the function `strip_newline`.\nUse the following context:\n```rust\nfn strip_newline(s: &mut String) {\n    if s.ends_with('\\n') {\n        s.pop();\n    }\n}\n\n```", "test": "#[cfg(test)]\nmod test {\n    use super::*;\n\n    #[test]\n    fn test_strip_all_newlines() {\n        let input = &mut [\"a1\".to_string()];\n        strip_all_newlines(input);\n        assert_eq!(input, &[\"a1\".to_string()]);\n\n        let input = &mut [\"a1\\n\".to_string()];\n        strip_all_newlines(input);\n        assert_eq!(input, &[\"a1\".to_string()]);\n\n        let input = &mut [\"a1\\n\".to_string(), \"a2\".to_string(), \"a3\\n\".to_string()];\n        strip_all_newlines(input);\n        assert_eq!(\n            input,\n            &[\"a1\".to_string(), \"a2\".to_string(), \"a3\".to_string()]\n        );\n    }\n}", "entry_point": "strip_all_newlines", "canonical_solution": "fn strip_all_newlines(lines: &mut [String]) {\n    lines.iter_mut().for_each(strip_newline);\n}", "contained": {"functions": ["iter_mut", "for_each", "strip_newline"], "operators": ["", "", ""]}}
{"task_id": "Rust/25", "prompt": "#[derive(Debug, PartialEq)]\nenum TemperatureRange {\n    Cold,\n    Warm,\n    Hot,\n}\n\n/// The function takes in a temperature as `u32` and encodes it into `TemperatureRange` enum. Cold\n/// ranges from 0 to 15 included, warm from 16 to 40 included and otherwise it's hot.\nfn map_range_to_enum(temperature: u32) -> TemperatureRange {", "instruction": "Write an idiomatic Rust function `map_range_to_enum(temperature: u32) -> TemperatureRange` to solve the following problem:\nThe function takes in a temperature as `u32` and encodes it into `TemperatureRange` enum. Cold ranges from 0 to 15 included, warm from 16 to 40 included and otherwise it's hot.\nUse the following context:\n```rust\n#[derive(Debug, PartialEq)]\nenum TemperatureRange {\n    Cold,\n    Warm,\n    Hot,\n}\n\n```", "test": "#[cfg(test)]\nmod test {\n    use super::*;\n\n    #[test]\n    fn test_map_range_to_enum() {\n        assert_eq!(map_range_to_enum(0), TemperatureRange::Cold);\n        assert_eq!(map_range_to_enum(12), TemperatureRange::Cold);\n        assert_eq!(map_range_to_enum(15), TemperatureRange::Cold);\n        assert_eq!(map_range_to_enum(16), TemperatureRange::Warm);\n        assert_eq!(map_range_to_enum(32), TemperatureRange::Warm);\n        assert_eq!(map_range_to_enum(40), TemperatureRange::Warm);\n        assert_eq!(map_range_to_enum(41), TemperatureRange::Hot);\n        assert_eq!(map_range_to_enum(u32::MAX), TemperatureRange::Hot);\n    }\n}", "entry_point": "map_range_to_enum", "canonical_solution": "fn map_range_to_enum(temperature: u32) -> TemperatureRange {\n    match temperature {\n        0..=15 => TemperatureRange::Cold,\n        16..=40 => TemperatureRange::Warm,\n        _ => TemperatureRange::Hot,\n    }\n}", "contained": {"functions": ["", "", ""], "operators": ["match", "", ""]}}
{"task_id": "Rust/26", "prompt": "#[derive(Debug, PartialEq, Eq)]\nenum Direction {\n    Up,\n    Down,\n    Left,\n    Right,\n}\n\n/// The function takes in a direction `Direction` and encodes it to a string, as follows: Up -> \"up\",\n/// down -> \"down\", Left -> \"left\", Right -> \"right\"\nfn encode_direction(dir: &Direction) -> &str {", "instruction": "Write an idiomatic Rust function `encode_direction(dir: &Direction) -> &str` to solve the following problem:\nThe function takes in a direction `Direction` and encodes it to a string, as follows: Up -> \"up\", down -> \"down\", Left -> \"left\", Right -> \"right\"\nUse the following context:\n```rust\n#[derive(Debug, PartialEq, Eq)]\nenum Direction {\n    Up,\n    Down,\n    Left,\n    Right,\n}\n\n```", "test": "#[cfg(test)]\nmod test {\n    use super::*;\n\n    #[test]\n    fn test_encode_direction() {\n        assert_eq!(encode_direction(&Direction::Down), \"down\");\n        assert_eq!(encode_direction(&Direction::Up), \"up\");\n        assert_eq!(encode_direction(&Direction::Left), \"left\");\n        assert_eq!(encode_direction(&Direction::Right), \"right\");\n    }\n}", "entry_point": "encode_direction", "canonical_solution": "fn encode_direction(dir: &Direction) -> &str {\n    match dir {\n        Direction::Up => \"up\",\n        Direction::Down => \"down\",\n        Direction::Left => \"left\",\n        Direction::Right => \"right\",\n    }\n}", "contained": {"functions": ["", "", ""], "operators": ["match", "", ""]}}
{"task_id": "Rust/27", "prompt": "enum Operation {\n    Add(u32),\n    Sub(u32),\n    Mul(u32),\n    Div(u32),\n}\n\n/// The function takes in the current amount as `u32` and applies a `Operation`. Operations: `Add` ->\n/// add the containing value, `Sub` -> substruct the containing value, `Mul` -> multiply with the\n/// contained value, `Div` -> divide by the contained value.\nfn apply_operation(curr: u32, op: &Operation) -> u32 {", "instruction": "Write an idiomatic Rust function `apply_operation(curr: u32, op: &Operation) -> u32` to solve the following problem:\nThe function takes in the current amount as `u32` and applies a `Operation`. Operations: `Add` -> add the containing value, `Sub` -> substruct the containing value, `Mul` -> multiply with the contained value, `Div` -> divide by the contained value.\nUse the following context:\n```rust\nenum Operation {\n    Add(u32),\n    Sub(u32),\n    Mul(u32),\n    Div(u32),\n}\n\n```", "test": "#[cfg(test)]\nmod test {\n    use super::*;\n\n    #[test]\n    fn test_apply_operation() {\n        assert_eq!(apply_operation(10, &Operation::Add(10)), 20);\n        assert_eq!(apply_operation(10, &Operation::Sub(10)), 0);\n        assert_eq!(apply_operation(10, &Operation::Mul(10)), 100);\n        assert_eq!(apply_operation(10, &Operation::Div(10)), 1);\n    }\n}", "entry_point": "apply_operation", "canonical_solution": "fn apply_operation(curr: u32, op: &Operation) -> u32 {\n    match op {\n        Operation::Add(x) => curr + x,\n        Operation::Sub(x) => curr - x,\n        Operation::Mul(x) => curr * x,\n        Operation::Div(x) => curr / x,\n    }\n}", "contained": {"functions": ["", "", ""], "operators": ["match", "", ""]}}
{"task_id": "Rust/28", "prompt": "/// The function takes in a name and an address as `str` slices. The string should be formatted as\n/// `Name is {name}, address is {address}`.\nfn format_strings(name: &str, address: &str) -> String {", "instruction": "Write an idiomatic Rust function `format_strings(name: &str, address: &str) -> String` to solve the following problem:\nThe function takes in a name and an address as `str` slices. The string should be formatted as `Name is {name}, address is {address}`.", "test": "#[cfg(test)]\nmod test {\n    use super::*;\n\n    #[test]\n    fn test_format_strings() {\n        assert_eq!(\n            format_strings(\"Herbert\", \"Firststreet 1\"),\n            \"Name is Herbert, address is Firststreet 1\".to_string()\n        );\n        assert_eq!(\n            format_strings(\"Herbert\", \"\"),\n            \"Name is Herbert, address is \".to_string()\n        );\n        assert_eq!(\n            format_strings(\"Hans\", \"Firststreet 1\"),\n            \"Name is Hans, address is Firststreet 1\".to_string()\n        );\n    }\n}", "entry_point": "format_strings", "canonical_solution": "fn format_strings(name: &str, address: &str) -> String {\n    format!(\"Name is {name}, address is {address}\")\n}", "contained": {"functions": ["format!", "", ""], "operators": ["", "", ""]}}
{"task_id": "Rust/29", "prompt": "/// The function should add up a range from 0 to `n` included as `u32`.\nfn add_up_range_to_n(n: u32) -> u32 {", "instruction": "Write an idiomatic Rust function `add_up_range_to_n(n: u32) -> u32` to solve the following problem:\nThe function should add up a range from 0 to `n` included as `u32`.", "test": "#[cfg(test)]\nmod test {\n    use super::*;\n\n    #[test]\n    fn test_add_up_range_to_n() {\n        assert_eq!(add_up_range_to_n(0), 0);\n        assert_eq!(add_up_range_to_n(10), 55);\n        assert_eq!(add_up_range_to_n(3), 6);\n    }\n}", "entry_point": "add_up_range_to_n", "canonical_solution": "fn add_up_range_to_n(n: u32) -> u32 {\n    (0..=n).sum()\n}", "contained": {"functions": ["sum", "", ""], "operators": ["range", "", ""]}}
{"task_id": "Rust/30", "prompt": "use std::iter::Sum;\n\n/// The function takes in a slice of generic type which implements `Sum` and `Clone` and returns the\n/// sum of the  values as the same generic type.\nfn sumup_values<T: Sum + Clone>(values: &[T]) -> T {", "instruction": "Write an idiomatic Rust function `sumup_values<T: Sum + Clone>(values: &[T]) -> T` to solve the following problem:\nThe function takes in a slice of generic type which implements `Sum` and `Clone` and returns the sum of the  values as the same generic type.\nUse the following context:\n```rust\nuse std::iter::Sum;\n\n```", "test": "#[cfg(test)]\nmod test {\n    use super::*;\n\n    #[test]\n    fn test_sumup_values() {\n        assert_eq!(sumup_values::<u32>(&[]), 0);\n        assert_eq!(sumup_values(&[1, 2, 12]), 15);\n        assert_eq!(sumup_values(&[1u16, 2, 12]), 15);\n        assert_eq!(sumup_values(&[1, 2, 12, 4]), 19);\n        assert_eq!(sumup_values(&[1u8, 2, 12, 4]), 19);\n        assert_eq!(sumup_values(&[1u128, 2, 12, 4]), 19);\n    }\n}", "entry_point": "sumup_values", "canonical_solution": "use std::iter::Sum;\n\nfn sumup_values<T: Sum + Clone>(values: &[T]) -> T {\n    values.iter().cloned().sum()\n}", "contained": {"functions": ["cloned", "sum", "iter"], "operators": ["", "", ""]}}
{"task_id": "Rust/31", "prompt": "#[derive(Debug)]\nstruct TestError;\n\nfn run(value: u32) -> Result<u32, TestError> {\n    match value {\n        0..=10 => Err(TestError),\n        _ => Ok(value * 10),\n    }\n}\n\n/// The function takes in a value as `u32` and should call the provided function `run`. After\n/// calling, the function should evaluate if the returned value from `run` is 10 times the input\n/// value. Any Error should be forwarded.\nfn run_program(value: u32) -> Result<bool, TestError> {", "instruction": "Write an idiomatic Rust function `run_program(value: u32) -> Result<bool, TestError>` to solve the following problem:\nThe function takes in a value as `u32` and should call the provided function `run`. After calling, the function should evaluate if the returned value from `run` is 10 times the input value. Any Error should be forwarded.\nUse the following context:\n```rust\n#[derive(Debug)]\nstruct TestError;\n\nfn run(value: u32) -> Result<u32, TestError> {\n    match value {\n        0..=10 => Err(TestError),\n        _ => Ok(value * 10),\n    }\n}\n\n```", "test": "#[cfg(test)]\nmod test {\n    use super::*;\n\n    #[test]\n    fn test_run_program() {\n        assert!(matches!(run_program(12), Ok(true)));\n        assert!(matches!(run_program(2), Err(TestError)));\n    }\n}", "entry_point": "run_program", "canonical_solution": "fn run_program(value: u32) -> Result<bool, TestError> {\n    run(value).map(|v| v / 10 == value)\n}", "contained": {"functions": ["map", "", ""], "operators": ["", "", ""]}}
{"task_id": "Rust/32", "prompt": "/// The function takes in a slice of strings and should try to parse each to `i32`. All Results\n/// should be returned.\nfn parse_strings_to_numbers(strings: &[String]) -> Vec<Result<i32, std::num::ParseIntError>> {", "instruction": "Write an idiomatic Rust function `parse_strings_to_numbers(strings: &[String]) -> Vec<Result<i32, std::num::ParseIntError>>` to solve the following problem:\nThe function takes in a slice of strings and should try to parse each to `i32`. All Results should be returned.", "test": "#[cfg(test)]\nmod test {\n    use super::*;\n\n    #[test]\n    fn test_parse_strings_to_numbers() {\n        assert_eq!(parse_strings_to_numbers(&[]), Vec::new());\n        assert_eq!(\n            parse_strings_to_numbers(&[\"1\".to_string(), \"2\".to_string()]),\n            vec![Ok(1), Ok(2)]\n        );\n        assert_eq!(\n            parse_strings_to_numbers(&[\"1\".to_string(), \"2\".to_string(), \"a\".to_string()]),\n            vec![Ok(1), Ok(2), Err(\"a\".parse::<i32>().unwrap_err())]\n        );\n    }\n}", "entry_point": "parse_strings_to_numbers", "canonical_solution": "fn parse_strings_to_numbers(strings: &[String]) -> Vec<Result<i32, std::num::ParseIntError>> {\n    strings.iter().map(|s| s.parse::<i32>()).collect()\n}", "contained": {"functions": ["parse", "map", "collect"], "operators": ["", "", ""]}}
{"task_id": "Rust/33", "prompt": "/// The function takes in a slice of strings and should try to parse each to `i32`. If a string\n/// cannot be parsed it should be ignored and only the successfully parsed ones should be returned.\nfn parse_strings_to_numbers(strings: &[String]) -> Vec<i32> {", "instruction": "Write an idiomatic Rust function `parse_strings_to_number(strings: &[String]) -> Vec<i32>` to solve the following problem:\nThe function takes in a slice of strings and should try to parse each to `i32`. If a string cannot be parsed it should be ignored and only the successfully parsed ones should be returned.", "test": "#[cfg(test)]\nmod test {\n    use super::*;\n\n    #[test]\n    fn test_parse_strings_to_number() {\n        assert_eq!(parse_strings_to_numbers(&[]), Vec::new());\n        assert_eq!(\n            parse_strings_to_numbers(&[\"1\".to_string(), \"2\".to_string()]),\n            vec![1, 2]\n        );\n        assert_eq!(\n            parse_strings_to_numbers(&[\"1\".to_string(), \"2\".to_string(), \"a\".to_string()]),\n            vec![1, 2]\n        );\n    }\n}", "entry_point": "parse_strings_to_numbers", "canonical_solution": "fn parse_strings_to_numbers(strings: &[String]) -> Vec<i32> {\n    strings\n        .iter()\n        .filter_map(|s| s.parse::<i32>().ok())\n        .collect()\n}", "contained": {"functions": ["filter_map", "parse", "collect"], "operators": ["", "", ""]}}
{"task_id": "Rust/34", "prompt": "/// The function takes in a slice of strings and should try to parse each to `i32`. Parsing errors\n/// should be collected. The function should return the successfully parsed numbers and the errors\n/// separately.\nfn parse_strings_to_numbers(strings: &[String]) -> (Vec<i32>, Vec<std::num::ParseIntError>) {", "instruction": "Write an idiomatic Rust function `parse_strings_to_numbers(strings: &[String]) -> (Vec<i32>, Vec<std::num::ParseIntError>)` to solve the following problem:\nThe function takes in a slice of strings and should try to parse each to `i32`. Parsing errors should be collected. The function should return the successfully parsed numbers and the errors separately.", "test": "#[cfg(test)]\nmod test {\n    use super::*;\n\n    #[test]\n    fn test_parse_strings_to_numbers() {\n        assert_eq!(parse_strings_to_numbers(&[]), (Vec::new(), Vec::new()));\n        assert_eq!(\n            parse_strings_to_numbers(&[\"1\".to_string(), \"2\".to_string()]),\n            (vec![1, 2], Vec::new())\n        );\n        assert_eq!(\n            parse_strings_to_numbers(&[\"1\".to_string(), \"2\".to_string(), \"a\".to_string()]),\n            (vec![1, 2], vec![\"a\".parse::<i32>().unwrap_err()])\n        );\n    }\n}", "entry_point": "parse_strings_to_numbers", "canonical_solution": "fn parse_strings_to_numbers(strings: &[String]) -> (Vec<i32>, Vec<std::num::ParseIntError>) {\n    let mut errors = vec![];\n    let numbers = strings\n        .iter()\n        .map(|s| s.parse::<i32>())\n        .filter_map(|r| r.map_err(|e| errors.push(e)).ok())\n        .collect();\n    (numbers, errors)\n}", "contained": {"functions": ["filter_map", "map_err", "parse"], "operators": ["", "", ""]}}
{"task_id": "Rust/35", "prompt": "/// The function takes in a slice of strings and should try to parse each to `i32`. The function\n/// should return the successfully parsed numbers or if a parsing error occurs it should return it\n/// immediately.\nfn parse_strings_to_numbers(strings: &[String]) -> Result<Vec<i32>, std::num::ParseIntError> {", "instruction": "Write an idiomatic Rust function `parse_strings_to_numbers(strings: &[String]) -> Result<Vec<i32>, std::num::ParseIntError>` to solve the following problem:\nThe function takes in a slice of strings and should try to parse each to `i32`. The function should return the successfully parsed numbers or if a parsing error occurs it should return it immediately.", "test": "#[cfg(test)]\nmod test {\n    use super::*;\n\n    #[test]\n    fn test_parse_strings_to_numbers() {\n        assert!(matches!(parse_strings_to_numbers(&[]), Ok(v) if v.is_empty()));\n        assert!(matches!(\n            parse_strings_to_numbers(&[\"1\".to_string(), \"2\".to_string()]), Ok(v) if v == vec![1, 2]\n        ));\n        assert!(matches!(\n            parse_strings_to_numbers(&[\"1\".to_string(), \"2\".to_string(), \"a\".to_string()]),\n            Err(e) if e == \"a\".parse::<i32>().unwrap_err()\n        ));\n    }\n}", "entry_point": "parse_strings_to_numbers", "canonical_solution": "fn parse_strings_to_numbers(strings: &[String]) -> Result<Vec<i32>, std::num::ParseIntError> {\n    strings.iter().map(|s| s.parse::<i32>()).collect()\n}", "contained": {"functions": ["map", "collect", "parse"], "operators": ["", "", ""]}}
{"task_id": "Rust/36", "prompt": "/// The function takes in a slice of `u32` and should seperate all even and odd values into two\n/// separate vectors. The first vector returned should be the even numbers.\nfn separate_values(values: &[u32]) -> (Vec<u32>, Vec<u32>) {", "instruction": "Write an idiomatic Rust function `separate_values(values: &[u32]) -> (Vec<u32>, Vec<u32>)` to solve the following problem:\nThe function takes in a slice of `u32` and should seperate all even and odd values into two separate vectors. The first vector returned should be the even numbers.", "test": "#[cfg(test)]\nmod test {\n    use super::*;\n\n    #[test]\n    fn test_separate_values() {\n        assert_eq!(\n            separate_values(&[1, 3, 5, 2, 1, 9, 10]),\n            (vec![2, 10], vec![1, 3, 5, 1, 9])\n        );\n        assert_eq!(\n            separate_values(&[1, 3, 4, 2, 3, 9, 6, 9]),\n            (vec![4, 2, 6], vec![1, 3, 3, 9, 9])\n        );\n    }\n}", "entry_point": "separate_values", "canonical_solution": "fn separate_values(values: &[u32]) -> (Vec<u32>, Vec<u32>) {\n    values.iter().partition(|&x| x % 2 == 0)\n}", "contained": {"functions": ["iter", "partition", ""], "operators": ["", "", ""]}}
{"task_id": "Rust/37", "prompt": "/// The function takes a buffer of chars and a filter function and returns a string of the filtered\n/// buffer. The filter returns `true` and `false`. If the filter returns `true` the char should\n/// remain in the out string.\nfn read_from_buffer_with_filter(buffer: &[char], filter_fn: impl Fn(&char) -> bool) -> String {", "instruction": "Write an idiomatic Rust function `read_from_buffer_with_filter(buffer: &[char], filter_fn: impl Fn(&char) -> bool) -> String` to solve the following problem:\nThe function takes a buffer of chars and a filter function and returns a string of the filtered buffer. The filter returns `true` and `false`. If the filter returns `true` the char should remain in the out string.", "test": "#[cfg(test)]\nmod test {\n    use super::*;\n\n    #[test]\n    fn test_read_from_buffer_with_filter() {\n        assert_eq!(\n            read_from_buffer_with_filter(&['a', 'b', 'c', 'j'], |c| *c != 'c'),\n            \"abj\"\n        );\n        assert_eq!(\n            read_from_buffer_with_filter(&['a', 'b', 'c', 'j'], |c| *c != 'j'),\n            \"abc\"\n        );\n        assert_eq!(\n            read_from_buffer_with_filter(&['a', 'b', 'c', 'j'], |c| *c != 'a'),\n            \"bcj\"\n        );\n        assert_eq!(read_from_buffer_with_filter(&[], |c| *c != 'a'), \"\");\n    }\n}", "entry_point": "read_from_buffer_with_filter", "canonical_solution": "fn read_from_buffer_with_filter(buffer: &[char], filter_fn: impl Fn(&char) -> bool) -> String {\n    buffer.iter().filter(|c| filter_fn(*c)).collect::<String>()\n}", "contained": {"functions": ["filter", "collect", ""], "operators": ["", "", ""]}}
{"task_id": "Rust/38", "prompt": "/// The function takes in a pointer of a function which takes in a string slice and returns a vector\n/// of strings. The main function should return a vector of strings which should be computet by using\n/// the supplied function pointer.\nfn split_string_with_function(func_ptr: *const (), string: &str) -> Vec<String> {", "instruction": "Write an idiomatic Rust function `split_string_with_function(func_ptr: *const (), string: &str) -> Vec<String>` to solve the following problem:\nThe function takes in a pointer of a function which takes in a string slice and returns a vector of strings. The main function should return a vector of strings which should be computet by using the supplied function pointer.", "test": "#[cfg(test)]\nmod test {\n    use super::*;\n\n    fn split(string: &str) -> Vec<String> {\n        string.split(\" \").map(|s| s.to_string()).collect()\n    }\n\n    #[test]\n    fn test_split_string_with_function() {\n        assert_eq!(\n            split_string_with_function(split as *const (), \"\"),\n            vec![String::from(\"\")]\n        );\n        assert_eq!(\n            split_string_with_function(split as *const (), \"Hello World!\"),\n            vec![String::from(\"Hello\"), String::from(\"World!\")]\n        );\n    }\n}", "entry_point": "split_string_with_function", "canonical_solution": "fn split_string_with_function(func_ptr: *const (), string: &str) -> Vec<String> {\n    let function = unsafe { std::mem::transmute::<_, fn(&str) -> Vec<String>>(func_ptr) };\n    (function)(string)\n}", "contained": {"functions": ["transmute", "", ""], "operators": ["unsafe", "", ""]}}
{"task_id": "Rust/39", "prompt": "use std::sync::{atomic::AtomicBool, Arc};\n\n/// The function takes in a flag which is of type `Arc` wrapping an `AtomicBool`. It should check if\n/// the flag is set and set it back to `false`. The loading of the atomic value should be in\n/// sequential order.\nfn is_flag_set_and_unset(flag: Arc<AtomicBool>) -> bool {", "instruction": "Write an idiomatic Rust function `fn is_flag_set_and_unset(flag: Arc<AtomicBool>) -> bool` to solve the following problem:\nThe function takes in a flag which is of type `Arc` wrapping an `AtomicBool`. It should check if the flag is set and set it back to `false`. The loading of the atomic value should be in sequential order.\nUse the following context:\n```rust\nuse std::sync::{atomic::AtomicBool, Arc};\n\n```", "test": "#[cfg(test)]\nmod test {\n    use super::*;\n\n    #[test]\n    fn test_is_flag_set_and_unset() {\n        let flag = Arc::new(AtomicBool::new(true));\n        assert_eq!(is_flag_set_and_unset(flag.clone()), true);\n        assert_eq!(flag.load(std::sync::atomic::Ordering::SeqCst), false);\n        let flag = Arc::new(AtomicBool::new(false));\n        assert_eq!(is_flag_set_and_unset(flag.clone()), false);\n        assert_eq!(flag.load(std::sync::atomic::Ordering::SeqCst), false);\n    }\n}", "entry_point": "is_flag_set_and_unset", "canonical_solution": "use std::sync::{atomic::AtomicBool, Arc};\n\nfn is_flag_set_and_unset(flag: Arc<AtomicBool>) -> bool {\n    flag.swap(false, Ordering::SeqCst)\n}", "contained": {"functions": ["swap", "", ""], "operators": ["", "", ""]}}
